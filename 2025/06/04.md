## 取り組んだ課題一覧
- 米国AI開発者がゼロから教えるDocker講座  Udemy
	
## わかったこと
- Dockerがあると環境構築が楽になる
- DockerはLinuxのコンテナ技術を使用している
- kernel（核）には人間が直接命令を出せないので、shell（殻）を介して命令を出す。shellはbashやzshなどのことで、ターミナルはshellに命令を出すためのアプリケーションのこと。（shell=ターミナルではない）
- command+スペースでスポットライト検索が可能
- 環境変数とは、OS上で動くプロセスが情報を共有するために使う変数のこと。`$`は環境変数の目印のようなもの。
- `echo $SHELL`でshellの中身を確認できる→`/bin/zsh`
- `export AGE=20`とすると環境変数を設定できる。`echo $AGE`で確認できる。
- Docker HubはDocker imageを管理するDokerレジストリのこと
- 一緒に開発をするときは、AさんBさん、テスト環境、本番環境が全て同じである必要がある。Dockerの同じコンテナを使用することで、同じ環境を共有することができる。
- 自分のパソコンのことをHostという。
- コマンドはDocker Desktopアプリがオンになっている状態で実行する
- `docker login`：docker hubにログインする
- `docker pull <image>` ：docker hubからimageをプルする
- `docker images`：ホストの中にある imageを確認する
- imageはDocker Hubのサイト上にある
- imageは一つのリポジトリで、その中にtagでいろいろなバージョンがある
- `docker run <image>`：imageからコンテナを作る
- `docker ps`：コンテナの一覧を表示する（アクティブのみ）
- `docker ps -a`：コンテナの一覧を表示する（非アクティブ含む）
- `docker run <image>`でコンテナを作成→コンテナの中のプログラムが実行される→終了したらexitする
- `docker run -it ubuntu bash`：Dockerコンテナを使って Ubuntu(OS) の仮想環境を立ち上げ、対話的に Bash シェルを開く
- `docker run <image>`は、imageがホストに無い（プルしていない）場合は、自動でライブラリからプルしてくれる
- Docker imageにはimage layerがある。コンテナが作られると新しい書き込み可能なimage layerが追加される。
- `exit`プロセスを終了してコンテナからホストに戻る（statusはexitedになる）
- Dockerを起動すると、デフォルトではroot権限となる
- `docker restart <コンテナID or コンテナ名>`：exitしたコンテナを再開する
- `docker exec <コンテナ> <コマンド>`：コンテナのプログラムを実行する（statusがexitedだとエラーになる）
- `docker exec -it <ubuntuのコンテナid> bash`：ubuntuコンテナでbashシェルを開く
- detach:`ctrl+p+q`：プロセスを立ち上げたままコンテナからホストに戻る（statusはupのまま）
- `docker attach <コンテナ>`：up状態のコンテナを再開する。attachはメインプロセスにアクセスするため、attach後にexitするとstatusはexitedになる。
- `docker commit <コンテナ> <new image>`：コンテナをDocker imageに保存する
- `docker commit <ubuntuのコンテナid> ubuntu:updated`：ubuntuにupdatedというタグをつける（:でタグをつける）
- 自分が作成したimageをDocer Hubにプッシュするために、Docer HubのページでCreate repositoryを押してリポジトリを作成する。
- リポジトリはimage単位とする。image名とはリポジトリ名:タグ名のこと。（省略するとタグはlatestとなる）プッシュするとimage名と同名のリポジトリに送られる。
- `docker tag <source> <target>`：image名に新しい名前をつける（前の名前も残り、同じ実体を参照する）
- `docker tag ubuntu:updated <username>/my-first-repo`：ubuntu:updatedという名前を<username>/my-first-repoという名前に変更する
- image名は実際は`<hostname>:<port>/<username>/<repository>:<tag>`という構成になっている。`<hostname>:<port>`はデフォルトで`registry-1.docker.io`（Docker Hub）、`<username>`はデフォルトで`library`、`<tag>`は`latest`となる。特に指定しなければデフォルト値が適用される。
- ubuntuを例にすると、`registry-1.docker.io/library/ubuntu:latest`となる。
- Docker Hub以外のリポジトリにプッシュする場合は、`registry-1.docker.io`の部分を送信先の`<hostname>:<port>`に変更する。
- `docker push <image>`：リポジトリにプッシュする。（追加されたimage layerのみプッシュされ、元のimage layerはMountedとなる）
- すでにあるimageと同じ名前のimageをプルすることはできない
- `docker rmi <image>`：image名を削除する
- `docker pull <image>` でlibrary同様にdocker hubの自分のリポジトリからimageをプルできる（docker hubにはプル用のコマンドが表示されている）
- `docker run -it ユーザー名/my-first-repo bash`：プルしてきたubuntuのimageを実行する
- `run` = `create`と`start`の両方を実行する。
- `docker create <image>`：imageからコンテナをたてる
- `docker start <container>`：imageに設定されているデフォルトコマンドを実行→exitする。（デフォルトコマンドの実行結果は表示されない。実行結果を表示するには`docker start -a  <container>`とする。）
- imageのデフォルトコマンドは`docker ps -a`で表示されるCOMMANDで確認できる。`docker run -it ubuntu bash`は`ubuntu`のデフォルトコマンドを`bash`で上書きしている。
- `-it`オプションは、`-i`（インプット可能にする）と`-t`（表示が綺麗になる・TABでの入力補完ができる）の組み合わせ。
- STDIN（キーボード入力）→プログラム→STDOUT（出力）orSTDERR（エラー出力）
- `docker rm <container>`：停止しているコンテナを削除する
- `docker stop <container>`：コンテナを止める（コンテナをスペース区切りで記述すると複数コンテナを一度に停止可能）
- `docker system prune`：停止しているコンテナを全て削除する
- 同じimageから複数のコンテナを作成すると、コンテナ同士は独立していてお互いに干渉しない。
- `docker run --name <name> <image>`：名前をつけてコンテナをたてる。すでに同じ名前のコンテナがある場合はエラーになる。
- `docker run -d <image>`（detached mode）：コンテナを起動後にdetachする。（バックグラウンドで動かす）
- `docker run --rm <image>`（foreground mode）：コンテナをExit後に削除する。（一回きりのコンテナ）


<br>

- Dokerfile
- imageはlibraryから持ってくるか、Dockerfileから作るか2通りの方法がある。Dockerfileにはimageの内容が記述されていて分かりやすい（imageの設計図）ので、実務ではほとんどDockerfileが使用される。
- 任意の場所にdocker ディレクトリを作り、Dockerfileを作成する。
- INSTRACTION argumentsの形で記述していく。（ターミナルからcode .でVSCodeを開く）
- `FROM ubuntu:latest`：ベースとなるDocker imageを決める。OSを設定することが多い。この上にレイヤーを積み上げていく。
- `RUN touch tesut`：サンプルファイル（例）を作る。RUNでDockerfileをカスタマイズする。RUN毎にレイヤーが作られる 。
- `CMD ["executable","param1","param2"]`：`executable`はコマンドのこと。原則Dockerfileの最後に記述する。CMDは一回のみ記述する。ubuntuなら`CMD ["/bin/bash"]`とすることが多い。（書かなくてもbashが実行されるが、書いた方がわかりやすい。）CMDはレイヤーを作らない。
- `docker build <directory>`Dockerfileからimageを作成する。
- `docker build .`：Dockerfileがあるディレクトリ内でコマンドを実行すると、ディレクトリ内のDockerfileを探して実行してくれる。（.はカレントディレクトリ）
- `docker build -t <name> <directory>`：名前をつけて実行する。（名前をつけないと<none>となる）
- コンテナに変更を加えてcommitでimageに保存すると、加えた変更が記録されないので外からはimageの中身がわからない。Dockerfileに変更内容を記述していくことで、だれが見てもわかるようになる。
- ubuntuではapt-get（またはapt）というコマンドでパッケージ管理をする。
- `apt-get update`：新しいパッケージリストを取得
- `apt-get install <package> (-y)`：<package>をインストールする。-yでインストール確認にyesと回答する。
- Docker imageのレイヤー数が多いとサイズが大きくなってしまうため、レイヤー数は最小限にする。レイヤーを作るのは`RUN`、`COPY`、`ADD`の3つ。コマンドを&&で繋げる・`\`で改行することで、レイヤーを減らすことができる。
- imageのレイヤー毎にPCにキャッシュ（保存）がされるので、追加情報は新しく`RUN`を記述することで新しいレイヤーのみ読み込まれ、ビルド時間を短縮できる。Dockerfileの作成中はRUNを細かく分けて、中身が決まったら&&で繋げて記述することで、効率的に作成ができる。




## 次やること
米国AI開発者がゼロから教えるDocker講座  Udemy
	
## 感じたこと
LinuxやGitを学んできたことでイメージがつかみやすく、あまりつまずかずに進められました。
`docker attach`後のstatus状態がよく分からず、理解に時間がかかりましたが`docker attach`はメインプロセスにアクセスしているということが分かり納得しました。


## 学習時間
今日:8.5h
今週:26h 
累計:348h