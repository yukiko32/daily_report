## 取り組んだ課題一覧
- SQL
	- スッキリわかるSQL入門
		- ブログ提出
		- 問題集
	- 達人に学ぶDB設計

	
## わかったこと

### 論理設計と正規化

#### ER図

- 独立エンティティと従属エンティティの区別は主キーに外部キーが含まれているかどうかでわかる
- 多対多のエンティティは関連エンティティを間につくることで1対多に変換できる

#### 論理設計とパフォーマンス

- 正規化すると結合（JOIN）が必要になるため、多用するとSQLの速度が遅くなる
- 対処法はSQL文のチューニングと、非正規化がある
- 正規化による整合性とパフォーマンスは強いトレードオフの関係にある
- サマリデータや選択条件を冗長に保持すると正規形は崩れるが、検索を高速化できる
- 非正規化は、更新のパフォーマンスを下げる、データのリアルタイム性を下げる、後続工程で設計変更すると手戻りが大きいというデメリットがある
- 高速化はまずは非正規化以外の方法で考え、非正規化は最後の手段にする
- 論理と物理はトレードオフの関係なので、論理設計の時点で物理レベルについても考える必要がある


#### データベースとパフォーマンス

- インデックス
	- インデックスはアプリケーションのコードやテーブルのデータに影響を与えない上、性能改善の効果が大きい
	- B-treeインデックスは汎用性が高い
	- レコード数が10万件以下の場合はほぼインデックスの効果は無い
	- インデックスは列のカーディナリティ（値の種類）が高いものにつける（値が平均的に分散しているものがベスト）
	- 複合列に対してインデックスを設定する場合は、カーディナリティも複合列に対して考える
	- インデックスが使われない例
		- インデックス列に演算を行っている
		- インデックス列にSQL関数を適用している
		- インデックス列に`IS NULL`を記述している（DBMSによる）
		- 否定条件(<>,!=)を使用している
		- 後方一致または中間一致のLIKEを使用している
		- 暗黙の型変換（明示せずに数値→文字列型など）を行っている
	- 主キーと一意（ユニーク）な列にはインデックスが内部的に作られるため、作成は不要
	- インデックスを作成した列は更新性能が劣化するため、インデックスの多用は避ける
	- インデックスを長期間使用すると構造が崩れて性能が劣化するため、定期的なメンテナンスが望ましい

- 統計情報
	- DBMSは統計情報（メタデータ）を頼りにSQLのアクセスパスを決定する
	- 統計情報の収集は、データが大きく更新された後になるべく早く、使用者の少ない夜間に実施する
	- 統計情報収集の対象（範囲）は、大きな更新のあったテーブルおよびインデックスとする
	- 現状の実行計画を変化させたくない（現状が最適だとわかっている）場合は、統計情報を凍結する


- パーティション
	- 指定した列を元に物理的にソートを行うことで、検索時の読み込みデータ量を減らし（対象のソート結果のみにアクセスするため）、高速化する
	- パーティションは、WHERE句でパーティションキーを検索条件に指定した場合のみ、効果がある
	- パーティションキーに偏りがあるデータの場合、データが多いパーティションだけ処理が遅くなるため、できるだけ均等にデータを割り振れるものに採用する
	- パーティションには種類があり、複数のパーティションを組み合わせることもできる（コンポジット・パーティション）

- ヒント句
	- ヒント句によって強制的に実行計画を変えることができる
	- 使いこなすには経験が必要となる
	- 基本的には最終手段と考える

- パラレルクエリ
	- 通常はシングルコアで実行されるクエリの処理を分割してマルチコア化する（リソースが潤沢に余っている場合に使用）
	- CPUやストレージがすでに限界に近い状態では、リソース限界に突き当たり遅延がひどくなる

- オンメモリ
	- メモリが潤沢に余っていてストレージI/Oがボトルネックになっている場合に、テーブルやインデックスのデータをメモリに載せることで高速化する


## 次やること
- 達人に学ぶDB設計


## 感じたこと
SQLのパフォーマンスを向上するにはいろいろなアプローチがあることがわかりました。パフォーマンスのことも頭に置いて設計を行っていかなければいけないと思いました。


## 学習時間
今日:7h
今週:13h 
累計:614h