## 取り組んだ課題一覧
- SQL
	- スッキリわかるSQL入門
		- 問題集
	- 達人に学ぶDB設計

	
## わかったこと

### 論理設計のアンチパターン

#### 非スカラ値（第1正規形未満）

- 一部のDBMSでは配列を格納できる機能があるが、これは正規形が崩れている状態
- 配列型は利用せず、第1正規形を守ったほうがよい
- データは意味的に分解できる限りなるべく分解したほうがよい。なぜなら、分解してあるものを結合することは容易いが、結合された状態のものをあとから分解するのは難しいから。

#### ダブルミーニング

- 一つの列に複数の意味を持つ値が格納されていること（例：体重と年齢）
- 列は変数ではないため、一度決めたら変更はしないようにする

#### 単一参照テーブル

- 一つのテーブル内にさまざまな意味の値を混在させること
- テーブル数が減るなどのメリットはあるが、それを上回るデメリットがあるので使用しない

#### テーブル分割

- 水平分割：レコード単位（横）にテーブルを分割すること
	- 拡張性に乏しく、高速化したければパーティションを使えばいいため、推奨されない
- 垂直分割：列単位（縦）にテーブルを分割すること
	- 分割に論理的な意味が無く、代替手段があるためこちらも推奨されない

#### 集約（テーブル分割の代替手段）

- 列の絞り込み
	- 頻繁に参照される列だけを持った新しいテーブル（データマート）を作成する
	- データマートは元テーブルの更新にあわせて同期する必要があるため、バッチ更新の間隔などを要件と照らし合わせて検討する
	- 新しいテーブルをつくるため、容量を圧迫する

- サマリーテーブル
	- 集約関数（SUMやAVG）でレコードを集約した状態で保持する
	- デメリットは列の絞り込みと同様

#### 不適切なキー

- 可変長文字列（VARCHAR）は普遍性がないためキーには設定しないようにする
- 同じデータを意味するキーは同じデータ型にする（暗黙のデータ変換に頼らない）

#### ダブルマスタ

- 同じ役割のマスタテーブルが複数存在する
- システム統合時にデータを統合しないと発生する

#### データマートのアンチパターン

- データマートとは、データウェアハウスから切り出した、小規模で各部門のユーザーが利用しやすい形に加工したテーブル群のこと
- データマートはユーザーの利便性と使用時のパフォーマンス向上のために作られる
- データマートは設計書を残すようにする

- ゾンビマート
	- 不要だが削除されていない（できない）データマートをゾンビマートとよぶ
	- ゾンビマートは容量を圧迫するためパフォーマンス低下に繋がる
- 多段マート
	- マートからカスケードしてマートを作ること
	- どのようなデータを取り出しているのか不明瞭であり、いつ時点のデータかもわからなくなりがちなため、極力避ける


#### アンチパターンを避けるべき理由

- 他の人が見てわかりにくいシステムになり、バグや開発効率の低下に繋がるため
- あとからテーブル設計を変更することは難しいため
- データ構造がプログラムやシステムを決めるので、良くないデータ構造をプログラムで挽回することはできない。また、保守にも苦労する。

#### マテリアライズドビュー

- 実体を持ったビューのこと（通常のビューは実体化されない、SELECT文自体のこと）
- 実データを保持するので、アクセス時にSELECT文が実行されないのがメリット
- リフレッシュ（データ更新）が必要で、テーブル同様にストレージを消費するのがデメリット


### 論理設計のグレーノウハウ

- アンチパターンほどではないものの、無神経に使うと開発や運用に支障をきたすものをグレーノウハウと位置付ける

#### 代理キー

- 主キーにできる一意キーがない、一意キーはあるが途中で指す対象が変化する、という場合に代理キー（人工的な主キー）を使用する
- 代理キーは論理モデルをわかりにくくするため、極力使用は避けて、自然キーを使うようにする
- タイムスタンプ（その時点の日時）またはインターバル（データが有効な期間）の列を作成することで、「履歴」データを管理し、自然キーとして主キーの役割も持たせられる
- 代理キーを使用する場合の実装方法
	- シーケンスオブジェクト：シーケンスオブジェクトを作成し、それにSELECT文でアクセスすることで連番を取得する
	- ID列：一意な連番を払い出すデータ型を設定する（DBMSごとに実装が統一されていないため、移植性が低い）
	- より柔軟で拡張性が高いため、可能な限りシーケンスオブジェクトの使用が推奨される
	- アプリケーション（プログラム）側で採番テーブルを用意することも可能だが、DBMSにシーケンスオブジェクトがある以上車輪の再発明になるため、推奨されない
	- シーケンスオブジェクト（採番テーブルも）のデメリットは、複数アクセスができないため、ロックにより遅延が発生する可能性があること


#### 列持ちテーブル

- 配列を使わずに、列を追加することで配列を模倣すること
-メリットはシンプルな設計になることと、入出力のフォーマットと合わせやすいこと
- デメリットは列の増減が難しいこと、値がない場合にNULLを使わなくてはならないこと
- 原則として列持ちテーブルは使わず、行持ちテーブルにする
- 行持ちと列持ちの変換はお互いにSQL文で可能なので、行持ちにしておき、必要に応じて列持ちに変換すると良い

#### アドホックな集計キー

- アドホック（場当たり的）な集計キーを必要時に追加してしまうと、テーブルがどんどん巨大化してしまう
- 解決策１：テーブルに集計キーを追加せず、新しいテーブルに分離し、結合して使用する
- 解決策2：集計キーを追加したビューを作成する
```
CREATE VIEW 都道府県_地方ビュー AS
SELECT
  県コード, 県名, 人口（万人）,
  CASE
    WHEN 県コード IN ('01', '02', '03') THEN '01' -- 例：北海道・東北
    WHEN 県コード IN ('22', '23', '24') THEN '02' -- 例：中部地方
    WHEN 県コード IN ('36', '37') THEN '03'       -- 例：四国地方
    ELSE NULL
  END AS 地方コード
FROM 都道府県;
```
- 解決策3：`GROUP BY`句でアドホックキーを作る
```
SELECT
  CASE
    WHEN 県コード IN ('01', '02', '03') THEN '01'
    WHEN 県コード IN ('22', '23', '24') THEN '02'
    WHEN 県コード IN ('36', '37') THEN '03'
    ELSE NULL END AS 地方コード,
  SUM(人口（万人）) 
FROM 都道府県
GROUP BY
  CASE
    WHEN 県コード IN ('01', '02', '03') THEN '01'
    WHEN 県コード IN ('22', '23', '24') THEN '02'
    WHEN 県コード IN ('36', '37') THEN '03'
    ELSE NULL
  END;
```

#### 多段ビュー

- ビューへのアクセスは、1.ビュー、2.テーブルの2段階で行われる
- 最初はテーブルを元にビューを作り、さらにそのビューをもとにビューが作られると、ビューを実行したときに関連するビューが全て実行されるため、パフォーマンスが悪い
- 依存関係も複雑になり管理が困難になるため、ビューは原則として一段にとどめておくのが良い（ビューを元にビューを作らないということ）
- 設計は極力シンプルにしておくこと（KISSの法則）


#### データクレンジング

- 元々のデータをデータベースに登録できる状態にする作業をデータクレンジングという
- データクレンジングはデータベース設計（論理/物理）の前に行う
- 一意のキーを特定する
- 人名などの表記揺れを解消して名称を統一する（名寄せ）
- フリーハンドが表記揺れの原因なため、最近は入力フォーマットに入力させることで名寄せのコストを抑えている


#### ビジネスロジック

- 複雑なロジックの実装やエラーハンドリングはアプリケーションコード側でせざるを得ない
- 結論は、主キー、参照整合性制約、NOT NULL制約という基本的なルールはデータベース側で実装し、それ以外のビジネスロジックはアプリケーションコード側で実装する
- データベースのトリガーでビジネスロジックを実装することは避ける

#### 一時テーブル

- 一時的なデータを保持するためのテーブルで、設定したスパンが終了すると自動で削除される
- マテリアライズドビューのように実データを保持するが、永続的にデータを保持しないという違いがある
- 統計情報収集をデータがINSERTされた後に行わなければいけないが、統計情報収集には時間がかかる
- データファイルに高性能なストレージを割り当てても、一時テーブルは一時ファイルに割り当てられてしまうため、効果がない
- 一時テーブル自体はグレーノウハウではないが、性能的に厳しい条件での設計が求められる

■ビュー、マテリアライズドビュー、一時テーブルの特徴
| 項目        | ビュー          | マテリアライズドビュー       | 一時テーブル       |
| --------- | ------------ | ----------------- | ------------ |
| データ鮮度     | 高（リアルタイム）    | 中（更新タイミング次第）      | 中（更新タイミング次第） |
| パフォーマンス   | 低            | 高                 | 中            |
| データを保持するか | しない          | 永続的に保持する          | 一時的に保持する     |
| データの格納領域  | －（実データを持たない） | 任意（通常はデータファイルと同じ） | 一時ファイル       |




### SQL

- 値が列1~列2の間に含まれるかを判定
```
WHERE 値 BETWEEN 列1 AND 列2
```


## 次やること
- 達人に学ぶDB設計


## 感じたこと
配列など、アンチパターンだと知らなければ使ってしまいそうだったので、学習できてよかったです。 アカウント登録時などに名字と名前の入力欄が分かれているのは、データを分割して保持するためだということがわかりました。 



## 学習時間
今日:7h
今週:20h 
累計:621h