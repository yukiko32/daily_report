## 取り組んだ課題一覧
- スッキリわかるSQL入門 問題集
- REST Udemy
	
## わかったこと

### REST

#### REST WebAPIサービス設計（基本）

##### リクエスト

- URIの設計
	- 短くし、冗長なパスを含まないことで入力しやすくする
	- 省略せず、人間が読んで理解できるようにする（誰が見てもわかるようにする）
	- 全て小文字とする
	- 単語はハイフンで繋げる。また、単語の連結をする前に、URIを見直せないか考える。
	- URIで表現しているのはリソースの集合のため、単語は複数形を利用する
	- エンコードが必要な文字（人間が見て意味がわからない文字）を使わない
	- アーキテクチャが分かると悪意あるユーザーによって脆弱性を突かれる危険があるため、サーバー側のアーキテクチャを反映しない
	- 改造しやすくする。（Hackable）システム依存の単語（例えばサーバーが分かれているからalphaやbetaを入れる等）は見たときに意味がわからないので含めないようにする。
	- バージョニング（v1など）は含めてOK
	- ルールを統一する（例えばクエリパラメータかパスパラメータどちらかにする等）

- HTTPメソッドの適用
	- URIがリソースを示すのに対し、HTTPメソッド（`GET`や`POST`）はリソースに対する操作を示す

- クエリとパスの使い分け
	- クエリパラメータ
		- ?に続くキーバリュー：`.../users?page=3`
		- 検索条件（絞り込み条件）などの省略可能な場合に使用する

	- パスパラメータ
		- URLに埋め込まれる：`.../users/123`
		- 一意なリソースを表すのに必要な場合に使用する


##### レスポンス

- ステータスコード
	- ステータスコードで処理結果の概要を把握する
	- `1XX`：情報
		- `100 Continue`：サーバーが処理中
		- `101 Switching Protocol`：プロトコルの切り替え要求
	- `2XX`：成功
		- `200 OK`：リクエスト成功。本文にデータが含まれる。
		- `201 Created`：リクエスト成功。新しいリソースが作成される。
		- `202 Accepted`：非同期ジョブ受付。実際の処理結果は別途受け取る。
		- `204 No Content`：リクエスト成功。クライアントのビュー変更無し。
	- `3XX`：リダイレクト
		- API利用者はリダイレクトを実装していないことが多いのでREST API では基本的に300番台は利用しない
		- `304 Not Modified`：キャッシュ利用
	- `4XX`：クライアントエラー
		- `400 Bad Request`：その他のクライアントエラー
		- `401 Unauthorized`：クライアントが認証されていない
		- `403 Forbidden`：リソースへのアクセス許可がない（リソースが存在することが分かってしまうので、隠したければ404にしておく）
		- `404 Not Found`：リソースが存在しない
		- `409 Conflict`：リソースが競合し処理失敗
		- `429 Too Many Requests`：アクセス回数が制限（レートリミット）を超えたため処理失敗
	- `5XX`：サーバーサイドエラー
		- `500 Internal Server Error`：サーバーサイドのアプリケーションエラー
		- `503 Service Unavailable`：サービスが一時的に利用不可（メンテナンスや過負荷）


- HTTPメソッドとステータスコード
	- `GET`
		- 成功：200,304
		- 失敗：400,401,403,404,429,500,503
	- `POST`
		- 成功：200,201,202
		- 失敗：400,401,403,409,429,500,503
	- `PUT`データ更新/データ登録
		- 成功：200,201,204
		- 失敗：400,401,403,404,409,429,500,503
	- `DELETE`
		- 成功：200,202,204（DLETEは返すものがないので基本は204を使用する）
		- 失敗：400,401,403,404,429,500,503


- データフォーマット
	- `XML`：タグに属性をつけてテキストを記述する
	- `JSON`：JavaScriptを元にしたフォーマットで、XMLに比べてデータ量が減らせる（XMLのタグは冗長なため）
	- `JSONP`：JavaScriptのソースコード。クロスドメインでデータを受け渡すことができる。
	- 指定方法は3種類ある
		- `クエリパラメータ`：`.../users?format=json`
		- `拡張子`：`.../users.json`
		- `リクエストヘッダー`：`Accept: application/json`
		- URIがリソースであることを考えると、リクエストヘッダーが推奨される


- レスポンスデータの内部構造設計で考慮すること
	- エンベロープ（レスポンスボディー内のメタ情報）はヘッダー情報と役割が被るので使わない
	- オブジェクトはできるだけフラットにする（JSONでネストを使わない）
	- ページネーションをサポートする情報（次ページを取得するキーとなる情報）を返す
	- プロパティの命名規則はAPI全体で統一する（スネークケースかキャメルケース）
	- 日付はRFC3339（W3C-DTF）形式を使う（インターネットで標準的に用いられるため）
	- 大きな数値（64bit整数）は文字列で返す（JavaScriptの通常の整数は32bit整数で、64bit整数は処理できないため）
	
- エラー表現の設計ポイント
	- エラー詳細はレスポンスボディに入れる（ステータスコードだけではエラー内容を伝えられないため）
	- エラーの際にHTMLが返らないようにする（HTMLではなくJSONで返す）
	- サービス閉塞時は"503"+"Retry-After"で再開見込み時期を返す


#### REST WebAPIサービス設計（応用）

##### リクエスト

- APIバージョンの表現
	- APIにバージョンを含めるかどうか
		- メリット：特定バージョンにアクセス可能なため、クライアント側で突然エラーにならない
		- デメリット：複数バージョンを並列稼働させるため、ソースコードなどの管理が複雑になる
		- 広く世間一般に公開するようなサービスは、APIバージョンを含めたURL設計を行う
	- バージョンを入れる場所
		- パス、クエリ、ヘッダーの３種がある
		- ヘッダーに`X-接頭辞`は現在は非推奨となっており、`サービス固有の接頭辞`が推奨されている
		- REST APIの設計としてはヘッダーに入れるのが推奨されるが、実情としてはパスが一番多いため、プロジェクトで議論する
	- バージョンの付け方
		- セマンティックバージョニング
		- メジャー：後方互換しない修正
		- マイナー：後方互換する機能追加
		- パッチ：後方互換するバグ修正
		- 後方互換とは、新しいものに置き換えて使えるかどうか
		- 管理の面から、APIは後方互換しなくなったタイミングでつけるのが推奨される（メジャーバージョンのみ利用）

- OAuthとOpenID Connect
	- 認証と認可
		- 認証は本人特定、認可はアクセス制御

	- OAuthとOpenID Connectの違い
		- 両方とも認可（アクセス制御）の仕組み
		- OpenID Connectは「OAuth（認可） + 本人情報取得」

	- OAuth概要
	- OpenID Connect概要

- JSON Web Token（JWT：ジョット）
	- 仕様：RFC 7519-JSON Web Token(JWT)で標準化
	- 特徴：署名による改ざんチェック、URL-safeなデータ、データの中身はJSON形式
	- 用途：認証結果をサーバーサイドではなくクライアントサイドで保存（ステートレスな通信の実現）
	- 基本構造：base64UrlEncode（ヘッダー）+"."+base64UrlEncode（ペイロード）+"."+base64UrlEncode（署名）
	- ヘッダー：署名で利用するアルゴリズムなどを定義する（noneは暗号化されないためNG）
	- ペイロード：保存したいデータの実態
	- 署名：改ざんされていないか確認するための署名
	- jwt.io：JWTをWeb上の画面で確認できる

- 大量アクセス対策
	- レートリミットとは
		- API化により簡単に大量アクセスができるようになるため、対策として時間あたりのアクセス制限をかける
	- レートリミットで考慮すること
		- 誰に対して：APIキーやユーザーID...
		- 何に対して：単一機能、機能群、API全体...
		- 制限回数：10回、100回...
		- 単位時間（Window）：10分、1時間、1日...
	- レートリミットアルゴリズム
		- ⚪︎回/⚪︎分のように決める
		- Fixed Window：次の時間枠に移るとアクセス回数がリセットされる（枠の切り替え前後にレートリミットの最大2倍のアクセスが発生する可能性がある）
		- Sliding Log：過去⚪︎分のログが制限回数を超えていなければアクセスできる（ログデータが溜まるので破棄についても考える必要がある）
		- Sliding Window：Fixed WindowとSliding Logを組み合わせて、アクセス集中を防ぎながら、ログを残さないようにする
	- 優良顧客やキャンペーン向けにアクセス制限の緩和が必要な場合もあるので、アクセス元ごとに一時的に設定変更できる仕組みを考慮する


##### レスポンス
- キャッシュ制御
	- クライアントがサーバーから受け取ったレスポンスをキャッシュ（一時保存）することができる
	- キャッシュさせる方法
		- キャッシュ制御に利用するヘッダーは2分類3パターン
		- Expires：キャッシュの利用期限を指定
		- Cache-Control + Date：キャッシュの可否と期限を指定
		- Last-Modified+ETag：リソースの最終更新日時を指定+特定バージョンを示す文字列を指定
	- キャッシュさせる単位
		- Vary:でキャッシュ判断に使用するヘッダーを指定する

- セキュリティ
	- APIはどこから呼ばれるのか
		- スマホアプリ
		- Webページ（scriptタグ、JavaScript）
		- 外部システム（バッチ）
	- XSS（クロスサイトスクリプティング）
		- 脆弱性：正規のサイトに不正なスクリプトを挿入することでユーザーの情報を引き出したり操作できてしまう
		- 対処法：レスポンスヘッダーを追加する
			- `X-XSS-Protection`："1"でXSSフィルタリング有効化
			- `X-Frame-Options`："DENY"でframeタグ呼び出しを拒否
			- `X-Content-Type-Options`："nosniff"でIE脆弱性対応
		
	- CSRF（クロスサイトリクエストフォージェリ）
		- 脆弱性：許可しないアクセス元からのリクエストを処理してしまう
		- 対処法１：許可しないアクセス元からのリクエストを拒否する
			- `X-API-Key`：システム単位で実行可否判断
			- `Authentication`：ユーザー単位で実行可否判断
		- 対処法２：攻撃者に推測されにくいトークンの発行/称号処理を実装
			- `X-CSRF-TOKEN`：トークンを使って実行可否判断

	- HTTP
		- 脆弱性：通信経路が暗号化されないので盗聴されやすい
		- 対処法：HTTPS（HTTP+SSL/TLS）を使用する

	- JSON Web Token(JWT)
		- 脆弱性：クライアント側で内容の確認/編集ができるため、サーバー側の検証が不十分だと改ざんされた情報を正規として受け入れてしまう
		- 対処法１：ヘッダーのalgに”none"以外を指定して署名を暗号化する
		- 対処法２：ペイロードのaudに想定する利用者を指定して受信時に検証する


## 次やること
- スッキリわかるSQL入門 問題集
- REST Udemy


## 感じたこと
HTTPなど、WEB技術の書籍で学んだ部分の記憶が薄れていたので、書籍を読み返しながら進めました。明日は内容の整理・まとめを行いたいと思います。


## 学習時間
今日:7.5h
今週:23.5h 
累計:671h