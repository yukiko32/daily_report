## 取り組んだ課題一覧
- JavaScript Primer
	
## わかったこと

### JavaScriptとは

- JavaScriptは常に変化を取り入れている言語で、言語自身や言語を取り巻く開発環境も変化している（古いコードが動かなくなるのではなく、新しいやり方が常に増えていくという意味での変化）
- JavaScriptは大文字小文字を区別する
- `"use strict";`をファイルの先頭または関数の先頭に書くことでそのスコープにあるコードはstrict modeで実行され、古く安全でない構文や機能を禁止する

### 変数と宣言

- 変数を宣言する場合はまず`const`で定義できないかを検討し、できない場合は`let`を使う

### 演算子

- `typeof`演算子を使用すると、プリミティブ型は値の型を、オブジェクト型は`object`を返す
- リテラルはデータ型の値を直接記述できる構文として定義されたもの
- `value == null`とすることで、`null`または`undefined`であると判定できる
- バグを防ぐため、基本は等価演算子（==）ではなく、厳密等価演算子（===）を使うべきである
- Nullish coalescing演算子(??)は、左辺の値がnullish（`null`または`undefined`）であるならば、右辺の評価結果を返す
- 三項演算子（`条件式 ? Trueのとき処理する式 : Falseのとき処理する式;`）のif文との違いは、値を返すこと

### 暗黙的な型変換

- `String(1); // => "1"`：数値から文字列へ明示的に変換する
- `Number("1"); // => 1`：文字列から数値へ明示的に変換する
- `Number.parseInt("42px", 10); // => 42`：文字列から整数を取り出す（第二引数に10を指定すると、10進数で取り出す）

### 関数と宣言

- デフォルト引数は、引数が渡されない場合にデフォルト値を設定できる
```
function 関数名(仮引数1 = デフォルト値1, 仮引数2 = デフォルト値2) {}
```
- Rest parametersは、仮引数名の前に...をつけた仮引数のことで、関数に渡された値が配列として代入される
```
function fn(...args) {
    // argsは、渡された引数が入った配列
    console.log(args); // => ["a", "b", "c"]
}
fn("a", "b", "c");
```
- Spread構文で配列を展開することができる
```
const array = [1, 2, 3];
// Spread構文で配列を展開
console.log(...array);  // 1, 2, 3
```
- 分割代入を使うことで、プロパティの値を取得できる
```
// 第1引数のオブジェクトから`id`プロパティを変数`id`として定義する
function printUserId({ id }) {
    console.log(id); // => 42
}
const user = {
    id: 42
};
printUserId(user);


function print([first, second]) {
    console.log(first); // => 1
    console.log(second); // => 2
}
const array = [1, 2];
print(array);
```
- 関数式とは、関数を値として変数へ代入している式のこと。
```
// 関数式は変数名で参照できるため、"関数名"を省略できる（無名関数）
const 変数名 = function() {
};
// 関数宣言では"関数名"は省略できない
function 関数名() {
}
```
- Arrow Functionでも無名関数を定義できる
```
// Arrow Functionを使った関数定義
const 変数名 = () => {
    // 関数を呼び出したときの処理
    // ...
    return 関数の返す値;
};
```
- Arrow Functionは以下のように短く書ける
```
// 次の２つの定義は同じ意味となる
const mulA = x => { return x * x; }; // ブロックの中でreturn
const mulB = x => x * x;            // 1行のみの場合はreturnとブロックを省略できる
```
- 関数の引数として渡される関数のことをコールバック関数と呼ぶ

### 式と文

- ブロック`{}`で終わる文の末尾には`;`は不要
```
// learn関数を宣言する関数宣言文（;は不要）
function learn() {
}
// 関数式をread変数へ代入（;が必要）
const read = function() {
};
```

### 条件分岐

- switch文は、if文の代用ではなく、関数と組み合わせて条件に対する値を返すパターンとして使うことが多い
```
function getECMAScriptName(version) {
    switch (version) {
        case "ES5":
            return "ECMAScript 5";
        case "ES6":
            return "ECMAScript 2015";
        case "ES7":
            return "ECMAScript 2016";
        default:
            return "しらないバージョンです";
    }
}
// 関数を実行して`return`された値を得る
getECMAScriptName("ES6"); // => "ECMAScript 2015"
```

### ループと反復処理

- forEachはfor文の条件式に相当するものはなく、配列のすべての要素を反復処理する。変数iといった一時的な値を定義する必要がないため、シンプルに反復処理を書ける。
- `break;`は処理中の文から抜けて次の文へ移行する
- `continue;`はは現在の反復処理を終了して、次の反復処理を行う
- Object.keys静的メソッドは引数のオブジェクト自身が持つ列挙可能なプロパティ名の配列を返す
```
const obj = {
    "a": 1,
    "b": 2,
    "c": 3
};
Object.keys(obj).forEach(key => {
    const value = obj[key];
    console.log(`key:${key}, value:${value}`);
});
```

### オブジェクト

- 分割代入を使ってプロパティを変数として定義する
```
const languages = {
    ja: "日本語",
    en: "英語"
};

// 分割代入を使わない
const ja = languages.ja;
const en = languages.en;

// 分割代入を使う
const { ja, en } = languages;
console.log(ja); // => "日本語"
console.log(en); // => "英語"
```
- プロパティの追加
```
// 空のオブジェクト
const obj = {};
// `key`プロパティを追加して値を代入
obj.key = "value";
console.log(obj.key); // => "value"
```
- オブジェクトは存在しないプロパティへアクセスした場合に`undefined`を返す（例外は発生しない）







## 次やること
- JavaScript Primer


## 感じたこと
JavaScript Primerに入りました。丁寧に解説されていて分かりやすいです。ボリュームがすごいので、じっくり読み進めたいと思います。


## 学習時間
今日:7.5h
今週:24.5h 
累計:808.5h