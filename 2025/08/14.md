## 取り組んだ課題一覧
- JavaScript Primer
	
## わかったこと

### 関数とthis

- ベースオブジェクトがない場合、`this`は`undefined`となる
- Arrow Functionは外側のスコープ（関数）が持つthisを参照する
- `call`メソッドは、`func.call(thisArg, arg1, arg2, ...);`のように、第一引数に渡すことで関数内で使われる this を強制的に指定できる
- `apply`メソッドは、`call`メソッドと違って`func.call(thisArg, [arg1, arg2, ...]);`のように引数を配列で渡す
- `bind`メソッドは、`func.bind(thisArg, arg1, arg2, ...);`のようにすることでthisの値を束縛（bind）した新しい関数を作成する
- 基本的にはメソッドとして定義されている関数は、メソッドとして呼ぶようにする


### クラス

- クラスは必ずコンストラクタ（インスタンス生成時に初期化を行うメソッド）を持つ。コンストラクタが不要の場合は記述を省略できるが、自動的に空のコンストラクタが定義される。
- `new クラス名();`でクラスをインスタンス化することができる
- `getter`と`setter`は以下のように記述する
```
class NumberWrapper {
    constructor(value) {
        this._value = value;
    }
    // `_value`プロパティの値を返すgetter
    get value() {
        return this._value;
    }
    // `_value`プロパティに値を代入するsetter
    set value(newValue) {
        this._value = newValue;
    }
}

const numberWrapper = new NumberWrapper(1);
console.log(numberWrapper.value); // => 1
numberWrapper.value = 42;
console.log(numberWrapper.value); // => 42
```
- コンストラクタは以下のように記述できる
```
class クラス {
    プロパティ名 = プロパティの初期値;
}
```
- 外からアクセスされたくないインスタンスのプロパティについては`#`をつける。`getter`と`setter`を経由しないと参照できなくなる。
```
class NumberWrapper {
    // valueはPrivateクラスフィールドとして定義
    #value;
    constructor(value) {
        this.#value = value;
    }
    // `#value`フィールドの値を返すgetter
    get value() {
        return this.#value;
    }
    // `#value`フィールドに値を代入するsetter
    set value(newValue) {
        this.#value = newValue;
    }
}

const numberWrapper = new NumberWrapper(1);
// クラスの外からPrivateクラスフィールドには直接はアクセスできない
console.log(numberWrapper.#value); // => SyntaxError: reference to undeclared private field or method #value
```
- 静的（スタティック）メソッドの定義と呼び出し
```
class クラス {
    static メソッド() {
        // 静的メソッドの処理
    }
}
// 静的メソッドの呼び出し
クラス.メソッド();
```
- クラスの継承は以下のように記述する
```
class 子クラス extends 親クラス {
}
```
- `super()`を使って子クラスから親クラスのconstructorメソッドを呼び出すことができる
```
// 親クラス
class Parent {
    constructor(...args) {
        console.log("Parentコンストラクタの処理", ...args);
    }
}
// Parentを継承したChildクラスの定義
class Child extends Parent {
    constructor(...args) {
        // Parentのコンストラクタ処理を呼び出す
        super(...args);
        console.log("Childコンストラクタの処理", ...args);
    }
}
const child = new Child("引数1", "引数2");
// "Parentコンストラクタの処理", "引数1", "引数2"
// "Childコンストラクタの処理", "引数1", "引数2"
```

### 例外処理

- `try-catch-finally`
```
try {
    console.log("try節:この行は実行されます");
    // 未定義の関数を呼び出してReferenceError例外が発生する
    undefinedFunction();
    // 例外が発生したため、この行は実行されません
} catch (error) {
    // 例外が発生したあとはこのブロックが実行される
    console.log("catch節:この行は実行されます");
    console.log(error instanceof ReferenceError); // => true
    console.log(error.message); // => "undefinedFunction is not defined"
} finally {
    // このブロックは例外の発生に関係なく必ず実行される
    console.log("finally節:この行は実行されます");
}
```
- `throw文`で例外を投げることができる
```
try {
    // 例外を投げる
    throw new Error("例外が投げられました");
} catch (error) {
    // catch節のスコープでerrorにアクセスできる
    console.log(error.message); // => "例外が投げられました"
}
```

### 非同期処理（Promise/Async Function）

- 非同期処理を扱う
	- Promiseというビルトインオブジェクト
	- Async Functionと呼ばれる構文的なサポート

- 同期処理はコードを順番に処理し、前の処理が終わるまで次の処理は行われない
- 非同期処理はコードを順番に処理するが、ひとつの非同期処理が終わるのを待たずに次の処理を評価する（同時に複数の処理を実行する）
- 同期処理も非同期処理もメインスレッドで行われるため、非同期処理は同期処理の影響を受ける

#### Promise

- `new Promise((resolve, reject)`の第一引数には成功時、第二引数には失敗時の関数を渡す
- `resolve` → 非同期処理が成功したときに呼ぶ。Promiseは Fulfilled（成功）状態 になる。
- `reject` → 非同期処理が失敗したときに呼ぶ。Promiseは Rejected（失敗）状態 になる。
- `onFulfilled` → Promiseが成功（resolveされた）ときに .then() で呼ばれるコールバック関数。
- `onRejected` → Promiseが失敗（rejectされた）ときに .then() または .catch() で呼ばれるコールバック関数。

```
/**
 * 1000ミリ秒未満のランダムなタイミングでレスポンスを疑似的にデータ取得する関数
 * 指定した`path`にデータがある場合、成功として**Resolved**状態のPromiseオブジェクトを返す
 * 指定した`path`にデータがない場合、失敗として**Rejected**状態のPromiseオブジェクトを返す
 */
function dummyFetch(path) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (path.startsWith("/success")) {
                resolve({ body: `Response body of ${path}` });
            } else {
                reject(new Error("NOT FOUND"));
            }
        }, 1000 * Math.random());
    });
}
// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録
// /success/data のリソースは存在するので成功しonFulfilledが呼ばれる
dummyFetch("/success/data").then(function onFulfilled(response) {
    console.log(response); // => { body: "Response body of /success/data" }
}, function onRejected(error) {
    // この行は実行されません
});
// /failure/data のリソースは存在しないのでonRejectedが呼ばれる
dummyFetch("/failure/data").then(function onFulfilled(response) {
    // この行は実行されません
}, function onRejected(error) {
    console.error(error); // Error: "NOT FOUND"
});
```

#### Promiseチェーン

- Promiseを返す関数を順番に .then() でつなぐ
- 各 then は成功時のコールバック（onFulfilled）を受け取り、新しい Promise を返す
- 途中でエラーが起きたら .catch() が呼ばれ、そこで処理される
- catch でエラーを処理すると、その後の then は「成功扱い」で呼ばれる
- catch 内でさらに throw （エラー発生）すると次の catch に伝わる




## 次やること
- JavaScript Primer


## 感じたこと
非同期処理について、半分くらいまで読み進めましたが動きをイメージするのとコードを理解するのが難しかったです。



## 学習時間
今日:8h
今週:40h 
累計:824h