## 取り組んだ課題一覧
- JavaScript
	- ガチで学びたい人のためのJavaScriptメカニズム
	
## わかったこと

- `this`とは「呼び出し元」のオブジェクトへの参照を保持するキーワードのこと
```
const person = {
    name: 'Tom',
    hello: function() {
        console.log('Hello ' + this.name);  // person.nameと同じ結果が返る
    }
}
person.hello();  // 呼び出し元はpersonなので、thisはpersonオブジェクトを参照する
```
- thisについて https://teratail.com/questions/127467
- thisの参照
	- オブジェクトのメソッドとして実行される場合、`this`は呼び出し元オブジェクトを参照する
	- 関数として実行される場合、`this`はグローバルオブジェクトを参照する
```
window.name = 'John';

const person = {
    name: 'Tom',
    hello: function () {
        console.log('Hello ' + this.name);
    }
}
person.hello();  // Hello Tom

function fn(ref) {
    ref();
}

// コールバック関数としてperson.helloを渡しているため、thisはグローバルオブジェクトを参照する(nameはJohnとなる)
fn(person.hello);  // Hello John
```
- `bind`を使用することで、`this`の参照先や引数を束縛（固定）することができる（`bind`は別のメモリ空間に関数を作成する）
```
window.name = 'John';

const person = {
    name: 'Tom',
    hello: function () {
        console.log('Hello ' + this.name);
    }
}
person.hello();  // Hello Tom

// thisの参照先をpersonに固定した関数を別のメモリ空間に作成する
const helloTom = person.hello.bind(person);

function fn(ref) {
    ref();
}

fn(helloTom);  // Hello Tom

function a(name) {
    console.log('hello ' + name);
}

const b = a.bind(null, 'Tim');  // 第一引数にはthisの参照先、第二引数には仮引数に渡す値を入れる

b();  // hello Tim
```

- `call`、`apply`を使用することで、`this`や引数の参照先を変更すると同時に関数を実行することができる
```
function a(name, name1) {
    console.log('hello ' + name + ' ' + name1);
}

const tim = { name: 'Tim' };
// 第二引数以下は配列
a.apply(tim, ['Tim', 'Bob']);  // hello Tim Bob
// 第二引数以下は引数
a.call(tim, 'Tim', 'Bob');  // hello Tim Bob
```
- アロー関数では省略して以下のように記述できる
```
const b = name => 'hello ' + name;
console.log(b('Tom'))  // hello Tom
```
- アロー関数はレキシカルスコープの`this`を参照する
- thisの使い分け
```
const person = {
    name: 'Tom',
    bye: function () {
        console.log('Bye ' + this.name);
    },
    hello: function (greeting) {
        console.log(greeting + ' ' + this.name);
        return greeting + ' ' + this.name;
    },

    hello1s() {
        // this.helloはただの関数として呼ばれているため、hello内のthisはundefinedになる
        // そのため、bindにthisを記述することでpersonオブジェクトを指定する
        setTimeout(this.hello.bind(this, 'hello'), 1000);

        // アロー関数は外側(hello1s)のthisを引き継ぐためthis===personとなる
        setTimeout(() => {
            this.hello('hello');
        }, 1000);

        // functionで書いたコールバックもthisがundefinedになってしまうため、_thisに保存しておくことでpersonを参照できる
        const _this = this;
        setTimeout(function () {
            _this.hello('hello');
        }, 1000);
    },
}

person.hello1s();  // 一秒後に hello Tom を表示
```
- コンストラクタ関数（オブジェクトを生成するための関数）を呼び出すには`new`を使用する→インスタンス化という
- プロトタイプはオブジェクトに存在する特別なプロパティでコンストラクタ関数とあわせて使用する。コンストラクタ関数をインスタンス化すると、`prototype`の参照がインスタンスの`__proto__`にコピーされる。
```
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Personにprototype.helloというプロパティを追加する
// helloメソッドはインスタンスから呼び出すことができる
// prototypeを使用することで、各インスタンスへ渡すのはオブジェクトへの参照となるため、メモリを節約できる
Person.prototype.hello = function () {
    console.log('hello ' + this.name);
}

const bob = new Person('Bob', 18);  // インスタンスを変数に格納する

bob.hello();  // hello Bob
```
- `instanceof`でインスタンスの種類を判別できる。`arg instanceof Array`とすると、`arg`が配列の場合に`true`となる
- クラスとは、コンストラクタ関数をクラス表記で書けるようにしたもの
```
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    // prototypeでの定義と同じ意味
    hello() {
        console.log('hello ' + this.name);
    }
}

const bob = new Person('Bob', 18);
console.log(bob);
```
- クラスの継承
```
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    hello() {
        console.log('hello ' + this.name);
    }
}

class Japanese extends Person {
    constructor(name, age, gender) {
        super(name, age);
        this.gender = gender;
    }

    hello() {
        console.log('Konnichiwa ' + this.name);
    }

    bye() {
        console.log('Sayonara ' + this.name);
    }
}

const taro = new Japanese('Taro', 23, 'Male');
console.log(taro);
taro.bye()
```
- `Symbol`はES5からES6に上がる際に既存で動いているコードを壊さないように導入された一意の値を得るためのプロパティ識別子であり、通常、開発者が使用することは無い





## 次やること
- ガチで学びたい人のためのJavaScriptメカニズム


## 感じたこと
this、bind、アロー関数、コンストラクタ関数、クラスなどについて学習しました。セクションごとの演習問題により、理解できていない部分に気づけました。thisの挙動について理解を深めることができたのでよかったです。


## 学習時間
今日:7.5h
今週:40.5h 
累計:915.5h