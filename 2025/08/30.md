## 取り組んだ課題一覧
- JavaScript
	- ガチで学びたい人のためのJavaScriptメカニズム
	
## わかったこと

- デバッグはSourcesタブでブレークポイントを置き、`command`+`r`で実行する
- PubSubパターンとは発行/購読パターン(パブリッシュ/サブスクライブ)のことで、例としてonメソッドとemitメソッドで関数の登録と実行を分離する。これによりアーキテクチャが疎結合になり、拡張性・再利用性が高まる。

#### 非同期処理

- スレッドは糸という意味で、連続して実行される一本の処理の流れのこと。
- メインスレッドは、JavaScriptの実行とレンダリング（画面描写）を行う
- 60fps（1秒間に60回画面更新）あればスムーズに見える
- 同期処理ではメインスレッドでコードが順番に実行される。一つの処理が完了するまで次の処理に進まない。
- 非同期処理は、一時的にメインスレッドから処理が切り離される
- `setTimeout`は非同期で行われる処理のため、`setTimeout`に指定した時間の間、メインスレッドで別の処理を行うことができる
- 実行待ちの非同期処理はタスクキュー（先入れ先出し）で管理される
- コールスタック（後入れ先出し）には実行待ちの処理が保管される
- コールスタックが空になるとイベントループがタスクキュー（非同期処理が保管されている）に伝えて、非同期処理がタスクキューからコールスタックに移動され、実行される
- コールバック関数で非同期処理を繋げるとネストが深くなってしまうため、`Promise`を使用する
```
new Promise(function (resolve, reject) {
  console.log('promise');
  // reject("bye");
  setTimeout(function () {
    resolve("hello");  // ()内の値はthenやcatchに渡すことができる
  }, 1000);
}).then(function (data) {
  console.log('then:' + data);
  // throw new Error();
  return data;  // returnにより、次のチェーンにdataを渡せる
}).then(function (data) {
  console.log('then:' + data);
  return data;
}).catch(function (data) {
  console.log('catch:' + data);
}).finally(function () {  // finallyは引数をとることができない
  console.log('finally');
})

console.log('global end');

// [実行結果]
// promise  最初に実行される
// global end  グローバルの処理が先に行われる
// then: hello  グローバルの処理が終わり、コールスタックが空になってから実行される
// then: hello
// finally
```
- 非同期処理を繋げる（プロミスチェーン）ためには、`then`メソッドのコールバック関数の`return`に`Promise`のインスタンスをセットする必要がある
```
function sleep(val) {
  return new Promise(function(resolve) {
    setTimeout(function() {
      console.log(val++);
      resolve(val);
    }, 1000);
  });
}

sleep(0).then(function(val) {
  return sleep(val);
}).then(function(val) {
  return sleep(val);
})
```
- `Promise.all`：すべての処理が完了後に`then`メソッドに移行する。一つでも失敗すると`catch`メソッドに移行する。成功したら結果の配列を返す。
- `Promise.race`：どれか一つの処理が完了後に`then`メソッドに移行する。すべて失敗すると`catch`メソッドに移行する。成功したら結果の値を返す。
- `Promise.allSettled`：すべての処理が完了後に`status: fulfilledまたはrejected`、`value`などを返す。処理が失敗しても`catch`メソッドへは移行しない
```
function sleep(val) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      console.log(val++);
      resolve(val);
    }, val * 500);
  });
}

Promise.all([sleep(2), sleep(3), sleep(4)])
  .then(function (date) {
    console.log(date);  // [3, 4, 5]
  });

Promise.race([sleep(2), sleep(3), sleep(4)])
  .then(function (date) {
    console.log(date);  // 3
  });

Promise.allSettled([sleep(2), sleep(3), sleep(4)])
  .then(function (data) {
    console.log(data);
  });
```
- 非同期処理にはマクロタスク（`settimeout`など）とマイクロタスク（`Promise`など）があり、マイクロタスクの方が先に実行される

- `Async/Await`により、`Promise`を更に直感的に記述することができる
- `Async`は`Promise`を返却する関数の宣言を行う。`async function`自体も`Promise`を返す。
- `Await`は`Promise`を返却する関数の非同期処理が完了するまで待つ
```
function sleep(val) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      console.log(val++);
      resolve(val);
    }, 1000);
  });
}

async function init() {
  let val = await sleep(0);  // awaitによりPromiseの結果を待って、resolveの値を返す
  val = await sleep(val);
  val = await sleep(val);
  val = await sleep(val);
  val = await sleep(val);
  throw new Error();
  // return val;
}

init().then(function (val) {
  console.log('hello' + val)
}).catch(function (e) {
  console.error(e);
});
```
- `fetch`メソッドは`Promise`オブジェクトを返す
- 例外処理
```
async function fetchUsers() {
  const response = await fetch('users.json');  // fetchはPromiseを返す
  if (response.ok) {
    const json = await response.json();  // .json()もPromiseを返す
    if (!json.length) {
      throw new Error('no data found');  // jsonを取得できない場合はエラーを投げる
    }
    return json;
  }
}

// 自作エラー
class NoDataError extends Error {
  constructor(message) {
    super(message);
    this.name = 'NoDataError';
  }
}

async function init() {
  try {
    const users = await fetchUsers();  // throw new Errorはtryで受け取る必要がある
    for (const user of users) {
      console.log(`I'm ${user.name}, ${user.age} years old`)
    }
  } catch (e) {
    if (e instanceof NoDataError) {  // 自作エラーの場合の処理
      console.error(e);
    } else {
      console.error('Oops, something went wrong');
    }
  } finally {  // 成功・失敗に関わらず実行される
    console.log('bye');
  }
  console.log('end');
}
init();
```
- 複数の`fetch`を行う際、ループで回すのではなく`Promise.all`を使ったほうが並列で処理が行われるためレスポンスが早くなる



#### モジュール

- モジュールとはソースコードを機能ごとに分割してメンテナンスしやすくする仕組み。代表的なものにESM（`import/export`）とCJS（`require/exports`）が存在する。
```
// ESMの例
// index.html
<script type="module" src="moduleB.js"></script>

// moduleA.js
export let publicVal = 0;

export  function publicFn() {
  console.log('publicFn called: ')
}

export default 1;

// moduleB.js
import defaultVal, { publicVal as val, publicFn as fn } from './moduleA.js';
// import * as moduleA from './moduleA.js';
console.log(val);  // 0
console.log(defaultVal);  // 1
fn();
```
- `<script type="module">`とすることで、自動で非同期処理や`strict`モードになる
- `strict`モードでは通常のJavaScriptで許容されている一部の書き方を制限する




## 次やること
- ガチで学びたい人のためのJavaScriptメカニズム


## 感じたこと
非同期処理についてコールスタックやタスクキューなど裏側の動作について学べたことで、なぜその順番で処理が完了するか理解することができました。JavaScript Primerで難しかった部分の理解を深められてよかったです。


## 学習時間
今日:6h
今週:6h 
累計:929h