## 取り組んだ課題一覧
- Reactの公式チュートリアルをやる
- モダンJavaScriptの基礎から始める挫折しないためのReact入門
	
## わかったこと

- stateの定義（コンポーネント関数のトップレベルでのみ記述が可能）
```
import { useState } from 'react';

const [count, setCount] = useState(0);
```
- stateは、setで値が更新されると次のレンダー（コンポーネント関数の実行）で値が更新される
```
console.log(count);  // 0
setCount(count + 1); // Request a re-render with 1
console.log(count);  // Still 0!
```
- `setCount(count + 1)`ではなく、`setCount(c => c + 1)`のように更新用関数を渡すことで、クリック時ではなく最新のstateを元に計算が行われる（現在の最新の state を c に入れて、その関数を実行して新しい state を計算する）
- stateはオブジェクトや配列を保持できるが直接書き換えるべきではなく、新しいオブジェクトやコピーを作成し、それを使ってstateをセットする必要がある（全てのオブジェクトを読み取り専用として扱う）
- `useState`のset関数をを使用することでReactに変更を伝え、再レンダーすることができる


- スプレッド構文を使用することで、オブジェクトや配列をコピーして置き換えることができる
```
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    setPerson({
      ...person,        // 既存の person の内容を展開（コピー）
      name: e.target.value  // その上で name を上書き
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,          // 既存の person の内容を展開（コピー）
      artwork: {
      ...person.artwork,  // artwork の既存の値をコピー
      title: e.target.value  // title だけ上書き
     }
    });
  }
}
```
- `Immer`ライブラリを使用すると、上記の冗長な記述を短縮できる
- イベントハンドラは以下のように定義する。通常、コンポーネントの内部で定義され、先頭に handle が付いた名前にする。
```
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>    // 関数を渡す
      Click me
    </button>
  );
}
```
- `e.stopPropagation() `を使うことで、イベントが上方向に伝播することを防ぐ
```
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}
```
- `e.preventDefault()`を使うと、デフォルトの操作（formの場合は再読み込み）を防ぐことができる
```
<form onSubmit={e => {
      e.preventDefault();
    }}>
```
- Reactは再レンダー(コンポーネント関数実行)時、変更のあったもののみ更新する

- Reactでの配列操作で使うメソッド

| 操作       | 使わない（配列を書き換える）         | 使う（新しい配列を返す）                          |
|------------|--------------------------------------|---------------------------------------------------|
| 追加       | `push`, `unshift`                    | `concat`, `[...arr]` (スプレッド構文)             |
| 削除       | `pop`, `shift`, `splice`             | `filter`, `slice`                                 |
| 要素置換   | `splice`, `arr[i] = ...` (代入文)    | `map`                                             |
| ソート     | `reverse`, `sort`                    | 先に配列をコピーしてから操作                      |

- `...arr.slice(0, 3),`とすることで、配列の最初から3個目までを展開できる
- 配列に変更を加える`sort`メソッドなどを使う場合は、以下のように配列をコピーしてからコピーした配列に変更を加えてset関数で置き換える
```
const nextList = [...list];
const nextList = list.slice();
// 変更処理...
setList(nextList);
```
- 配列をコピーしても個々の値は元の配列への参照であるため、値を代入すると元の配列も書き変わる。値を書き換える場合はmap関数で新しいオブジェクトをつくり置き換えるようにする（mapは新しい配列を返すのでコピーは不要）
```
// NG
const myNextList = [...myList];
const artwork = myNextList.find(a => a.id === artworkId);
artwork.seen = nextSeen; // 元の配列を書き換えてしまう
setMyList(myNextList);

// OK
setMyList(myList.map(artwork => {
  if (artwork.id === artworkId) {
    return { ...artwork, seen: nextSeen };  // 新しいオブジェクトで置き換える
  } else {
    // No changes
    return artwork;
  }
}));
```
- 配列もオブジェクトと同様に`Immer`を使うことで`artwork.seen = nextSeen`のような書き方ができる
```
// 対象部分のみ
import { useImmer } from 'use-immer';

const [myList, updateMyList] = useImmer(
    initialList
  );

function handleToggleMyList(id, nextSeen) {
    updateMyList(draft => {
      const artwork = draft.find(a =>
        a.id === id
      );
      artwork.seen = nextSeen;
    });
  }
```
- `Immer`は`draft`というProxy オブジェクトを作成する。`draft`に対して操作を行うことで代入や配列へのpushなど破壊的な操作が可能となる


- React は同じコンポーネントが再描画される場合、キーが同じなら state を保持したまま再利用する。逆に キーが変わると「別のコンポーネント」として扱い、前の state は捨てて新しくマウントし直す ので、useState() が最初からやり直される。

- リデューサとは、「現在の状態」と「アクション」を受け取って、新しい状態を返す関数のこと
```
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return state + 1;
    case 'decrement':
      return state - 1;
    default:
      return state;
  }
}

const [count, dispatch] = useReducer(reducer, 0);

dispatch({ type: 'increment' }); // 1増やす
dispatch({ type: 'decrement' }); // 1減らす
```


## 次やること
- Reactの公式チュートリアルをやる
- モダンJavaScriptの基礎から始める挫折しないためのReact入門

## 感じたこと
state内のオブジェクトと配列の更新、Immerを使った記述方法などについて学習しました。
チュートリアルのコードが難しくしっかりとは理解できていませんが、チャレンジ問題を解くことで少しずつReactの記法に慣れてきました。



## 学習時間
今日:7h
今週:19h 
累計:983.5h