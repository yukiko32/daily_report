## 取り組んだ課題一覧
- Next.js公式チュートリアル

	
## わかったこと

#### React Server Actions

- React Server Actionsのメリット
	- サーバー上で非同期コードを直接実行できる。（APIエンドポイントを作成する必要がない）
	- 暗号化されたクロージャ、厳密な入力チェック、エラーメッセージのハッシュ、ホストの制限などの機能が含まれ、セキュリティが強化される
	- DB の秘密情報やロジックをクライアントに晒さずに処理できる
	- JavaScriptがまだクライアントにロードされていない場合でも、フォームが機能する

```
// app/actions.ts
"use server"; // ← サーバーアクション宣言

export async function create(formData: FormData) {
  // サーバー上で実行される
  const title = formData.get("title");
  await db.insert("todos", { title });
}
```
```
// app/page.tsx
import { create } from "./actions";

export default function Page() {
  return (
    <form action={create}>   ← form actionに関数を渡す
      <input type="text" name="title" />
      <button type="submit">Add</button>
    </form>
  );
}
```

#### zod

- Zod は TypeScript/JavaScript 向けのスキーマ宣言とバリデーションのライブラリ
- スキーマ定義：データの形（型）や制約を宣言できる
- バリデーション：実際に受け取ったデータ（フォームや API から）をスキーマに照らして検証できる
- 型推論：TypeScript と組み合わせると、スキーマから型が自動生成される
```
import { z } from "zod";

// スキーマ定義
const FormSchema = z.object({
  id: z.string(),                       // 文字列でなければエラー
  customerId: z.string(),               // 文字列
  amount: z.coerce.number(),            // 数値に変換（文字列 "123" → 数値 123）
  status: z.enum(["pending", "paid"]),  // "pending" か "paid" しか許可しない
  date: z.string(),                     // 文字列（日付文字列を期待）
});
```
```
// 検証対象データ
const data = {
  id: "abc123",
  customerId: "cust01",
  amount: "500",     // 文字列でもOK、coerceで数値化される
  status: "pending",
  date: "2025-09-29",
};

// バリデーション（.paseは失敗時に例外を投げるのでエラーハンドリング要）
const result = FormSchema.safeParse(data);

if (!result.success) {
  console.error(result.error.format()); // エラー詳細
} else {
  console.log(result.data); // 型安全なデータ（amountはnumberに変換済み）

```
- 型を自動生成
```
import { z } from "zod";

const InvoiceSchema = z.object({
  id: z.string(),
  customerId: z.string(),
  amount: z.number(),
  status: z.enum(["pending", "paid"]),
  date: z.string(),
});

// 型を自動生成
type Invoice = z.infer<typeof InvoiceSchema>;

const createInvoice = (invoice: Invoice) => {
  // invoice は型安全 + 実行時にバリデーション可能
};
```

#### キャッシュ削除とリダイレクト

- キャッシュ削除とリダイレクトで、最新データを表示する
```
// パスに対応する静的キャッシュが削除される
  revalidatePath("/dashboard/invoices");
  // リダイレクトで新しいデータを取得して再生成されるため、最新のデータが反映されたページが表示される
  redirect("/dashboard/invoices");
```


#### ダイナミックルートセグメント

- データに基づいてルート（パス）を作成する場合はダイナミックルートセグメントを使う
- フォルダ名を`[]`で囲って作成することで、動的なルートセグメントを作成できる。例えば`/dashboard/invoices/[id]/edit/page.tsx`というフォルダ構成にすると、`/dashboard/invoices/2/edit`のようなURLになる
- 動的ルートセグメントは`params`オブジェクトとして受け取れる
- リンクの例
```
<Link href={`/dashboard/invoices/${id}/edit`} />
```
- `/dashboard/invoices/[id]/edit/page.tsx`では`props`として`params`(`[id]`部分)を受け取れる
```
export default async function Page(props: { params: { id: string } }) {
  const params = props.params;
  const id = params.id;
  // ...
}
```
- サーバーアクションへ引数を持つ関数を直接渡すことはできないため、バインドしてから渡す
```
import { updateInvoice } from '@/app/lib/actions';

// これはNG
<form action={updateInvoice(id)}>

// idをバインドした関数を生成し、その関数をactionへ渡す
const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);
 return <form action={updateInvoiceWithId}>{/* ... */}</form>;
```

#### エラー処理

##### すべてのエラーの処理

- `error.tsx`を使うことですべてのエラーに対応できる
- `/dashboard/invoices/error.tsx` を作ると、この invoicesフォルダ配下のページやレイアウトで throwされたエラーを表示できる
- `error.tsx`には`'use client';`を記述し、クライアントコンポーネントにする必要がある
- `error.tsx`は`error`と`reset`のpropsを受け取る
	- `error`：errorインスタンス
	- `reset`：実行するとルートセグメント（`/dashboard/invoices`）を再レンダリングする
```
"use client";

import { useEffect } from "react";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <main>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // ルートセグメントを再レンダリング
          () => reset()
        }
      >
        Try again
      </button>
    </main>
  );
}
```

##### 404エラーの処理

- 404エラーは`notFound`を使う
- `notFound`は`error.tsx`よりも優先される
- `/dashboard/invoices/[id]/edit/`のURLで存在しないidにアクセスが発生した場合に404エラー画面を表示するには、`/dashboard/invoices/[id]/edit/page.tsx`に以下を記述する
```
import { notFound } from 'next/navigation';

if (!invoice) {
    notFound();
  }
```
- `/dashboard/invoices/[id]/edit/not-found.tsx`を作成し、404エラー画面のコンポーネントを作成する


#### アクセシビリティの向上

##### プラグイン

- ESLintを使用することで、altテキストのない画像がある場合などに警告を出せる

##### フォームのアクセシビリティ

- フォームのアクセシビリティを向上する
	- セマンティックHTMLを使用する
	- ラベル付けを行う（`<label>`と`htmlFor`属性を含める）
	- フォーカスアウトラインを設定する

##### フォームの検証

- クライアント側：`input`要素に`required `を記述することで空白の場合にメッセージを出す
- サーバー側：`useActionState`を使用する

###### useActionState

- `useActionState`はサーバーアクションと組み合わせて使うReactフックで、フォーム送信などのサーバーアクションの状態をフロントエンドで追跡することができる
- フックのため`"use client"`の記述が必要
```
'use client';
 
import { useActionState } from 'react';
```
- `useActionState`は二つの引数を取る(`serverAction`, `initialState`)
	- `serverAction`（必須）：型: `(formData: FormData) => void | Promise<void>` などのサーバーアクション関数で、フォームの`action`属性に渡すサーバーアクション関数を指定する。この関数の状態（送信中、成功、エラー）を監視するための対象となる。
	- `initialState`（任意）：`ActionState`オブジェクトの初期値（例: `{ pending: false, error: null, result: null }`）
- `useActionState`は2つの値を返す`[state, formAction]`
	- `state`：型: `{ pending: boolean; error: any; result: any }`の、サーバーアクションの状態を表すオブジェクト。UI の表示（ローディング中のスピナー、エラー表示など）に使う。
	- `formAction`：型: `(formData: FormData) => void | Promise<void>`の、実際にフォームに`action`として渡す関数。
```
import { createInvoice, State } from '@/app/lib/actions';
import { useActionState } from 'react';

export default function Form({ customers }: { customers: CustomerField[] }) {
  const initialState: State = { message: null, errors: {} };
  const [state, formAction] = useActionState(createInvoice, initialState);
 
  return <form action={formAction}>...</form>;
}
```



## 次やること
- Next.js公式チュートリアル


## 感じたこと
サーバーアクション、zodライブラリ、動的ルート、エラー処理などについて学習しました。
useActionStateやzodでのバリデーションのコードの理解に苦戦しているので、明日はもう少し理解できるようにしたいです。


## 学習時間
今日:7h
今週:19.5h 
累計:1124h